*****	GENERATE PARTNER & SIBLING SEQUENCES	*****

use "$ggstemp/long_HH.dta", replace



* =========================================
* Generate all state variables
* =========================================

forvalues month = 0/167{		//Union	
		
	gen UNION_STATE`month'= .
	
}

forvalues month = 0/167{		//Marriage	
		
	gen MARR_STATE`month'= 888
	
}

forvalues month = 0/167{		//Marriage-union

	gen MU_STATE`month'= .
	
}

forvalues month = 0/167{		//Partner

	gen PARTNER_STATE`month'= .
	
}

forvalues month = 0/167{		//Full siblings

	gen FULLSIB_STATE`month' = 0
	
}

forvalues month = 0/167{		//Half siblings

	gen HALFSIB_STATE`month' = 0
	
}

********************************************************************************
********************************************************************************



* =========================================
* Set union, marriage and sibling states
* =========================================

forvalues month = 0/167{


	forvalues i = 1/9{					// Loop through each partner, except partner 10

		if `i' < 10 local x = `i'+1 	// Define local x as the next partner
		
			// Set Union state to single if between relationships
		replace UNION_STATE`month' 		= 888 if 								/// 888 = unpartnered
				(KIDBORN_YM + `month'	>= ISEP_YM`i') & 						///
				(KIDBORN_YM + `month' 	< IUNION_YM`x')							
		
			// Set union state to single if month is before first union
		replace UNION_STATE`month'		= 888 if 								/// 
				(KIDBORN_YM + `month' 	< IUNION_YM1) 
		
		
			// Set mothers to single if missing information on union start 
			// but have information on  marriage
		replace UNION_STATE`month'		= 888 if 								/// 
				(KIDBORN_YM + `month' 	< IMARR_YM1) & MARR_1 == 1 & 			///
				missing(IUNION_YM1)
		
			// Set union state to partner number if month is during union
		replace UNION_STATE`month' 		= `i' if 								///
				(KIDBORN_YM + `month' 	>= IUNION_YM`i') & 						///
				((KIDBORN_YM + `month' 	< ISEP_YM`i') | SEP_`i'==0)
		
		
			// Set marriage state to partner number if month is during marriage
		replace MARR_STATE`month' 		= 	`i' if 								///
				(KIDBORN_YM + `month'	>= IMARR_YM`i') & 						///
				((KIDBORN_YM + `month' 	< IDIV_YM`i') | DIV_`i'==0)

		
	}
	
	// Define state for partner 10
	replace UNION_STATE`month' 		= 888 if									///
			(KIDBORN_YM + `month'	>= ISEP_YM10)
	
	replace UNION_STATE`month' 		= 10 if 									///
			(KIDBORN_YM + `month' 	>= IUNION_YM10) &							///
			((KIDBORN_YM + `month'	< ISEP_YM10) | SEP_10==0)
	
	replace MARR_STATE`month'		= 	10 if									///
			(KIDBORN_YM + `month'	>= 	IMARR_YM10)	&							///
			((KIDBORN_YM + `month'	<	IDIV_YM10) | DIV_10==0)
	
	
/*	
	// Set Full-sib and half-sib state
	forvalues sib = 1/16{
	
		if UNION_STATE0 != 88 local dad = UNION_STATE0 
		
		replace FULLSIB_STATE`month' =	FULLSIB_STATE`month' + 1 				///
			if 	(IKID_YM + `month')	>= 	IKID_YM`sib'				&			///
				IKID_YM`sib'		>= 	IUNION_YM`dad'				&			///
				((IKID_YM`sib'' 	< 	ISEP_YM`dad') 	| 	SEP_`dad'==0)
				
		replace HALFSIB_STATE`month' =	HALFSIB_STATE`month' + 1				///
			if	(IKID_YM + `month')	>= 	IKID_YM`sib'				&			///
				(IKID_YM`sib' < IUNION_YM`dad'	| IKID_YM`sib'' >= ISEP_YM`dad')///
										
	} */
}

// Drop those missing information on both marriage and union
forvalues month = 0/167{

	drop if missing(MARR_STATE`month') & missing(UNION_STATE`month')
}

********************************************************************************
********************************************************************************


* =========================================
* Recode state number of partners so that 
* they represent the order in the child's
* life rather than the mothers
* =========================================


// Find the first partner for both union and marriage
egen union_state_min = rowmin(UNION_STATE*) 
egen marr_state_min = rowmin(MARR_STATE*)

// Get highest ranking union
sum UNION_STATE167 if UNION_STATE167 != 888
local highest_union = r(max)

// Get highest ranking marriage
sum MARR_STATE167 if MARR_STATE167 != 888
local highest_marr = r(max)

forvalues month = 0/167{

	// Set union state to missing if single
	replace UNION_STATE`month' 	=. if UNION_STATE`month'	== 888 
	replace MARR_STATE`month' 	=. if MARR_STATE`month' 	== 888 
	
	// Set the union state to be the first partner if the first partner
	// is equal to the highest ranking union
	replace UNION_STATE`month'	= 1 if union_state_min 	== `highest_union'
	replace MARR_STATE`month' 	= 1 if marr_state_min 	== `highest_marr'
	
	// Set union to zero if union state is the highest ranking union
	// (This will be replaced by the highest ranking union in the next loop)
	replace UNION_STATE`month' 	= 0 if UNION_STATE`month' 	== `highest_union'
	replace MARR_STATE`month' 	= 0 if MARR_STATE`month' 	== `highest_marr'


	// For all other cases, set the union state to the current state minus
	// the first state plus one
	replace UNION_STATE`month' = UNION_STATE`month' - union_state_min + 1 if 	///
		UNION_STATE`month' > 1 & UNION_STATE`month' < 888 & 					///
		UNION_STATE`month'!= `highest_union'
	
	replace MARR_STATE`month' = MARR_STATE`month' - marr_state_min + 1 if 		///
		MARR_STATE`month' > 1 & MARR_STATE`month' < 888 & 						///
		MARR_STATE`month'!=`highest_marr'

}

// Find the last partner 
egen union_state_max = rowmax(UNION_STATE*)
egen marr_state_max = rowmax(MARR_STATE*)

forvalues month = 0/167{

	// Set union state to the highest ranking partner 
	// (i.e. substitute the zero previously generated)
	replace UNION_STATE`month' = union_state_max + 1 if 						///
	UNION_STATE`month' == 0 
	
	replace MARR_STATE`month' = marr_state_max + 1 if 							///
	MARR_STATE`month' == 0 
	
	// Substitute back 888 for single
	replace UNION_STATE`month' = 888 if UNION_STATE`month' == .
	replace MARR_STATE`month' = 888 if MARR_STATE`month' == .


}

********************************************************************************
********************************************************************************

* =========================================
* Generate combined marriage-union variable
* and a union variable only considering
* partner order and not union type
* =========================================

forvalues month = 0/167{		//Marriage-union
			
	// Set marriage-union to married if married state matches union state
	replace MU_STATE`month' = 100 + UNION_STATE`month' if						///
			(MARR_STATE`month' == UNION_STATE`month')
			
	// Set marriage-union to married if no union recorded but marriage is recorded
	replace MU_STATE`month' = 100 + MARR_STATE`month' if						///
			UNION_STATE`month' == 888 & MARR_STATE`month' < 888
			
	// Set marriage-union to union state if 
	replace MU_STATE`month' = UNION_STATE`month' if								///
			MARR_STATE`month' == 888
	
}

count // 17,223
forvalues month = 0/167{

drop if MU_STATE`month' == .

}
count // 16,593

forvalues month = 0/167{

replace PARTNER_STATE`month' = 888 if MU_STATE`month' == 888
replace PARTNER_STATE`month' = mod(MU_STATE`month',10) if MU_STATE`month' != 888

}


drop _merge union_state_min union_state_max marr_state_min marr_state_max
save "$ggstemp/state_sequence_set.dta", replace


